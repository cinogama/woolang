import woo.std;
import test_tool;

import pkg.thread;

namespace test_thread
{
    let mut summ = 0;

    let created_threads = []mut: vec<thread>;
    let thread_count = 4;

    let test_vec = []mut: vec<typeof(nil)>;

    func main()
    {
        let mut i = 0;
        while (i<thread_count)
        {
            created_threads->add(
                thread::create(
                    func(id:int)
                    {
                        let mut c = 0;
                        while (c < 100000)
                        {
                            test_vec->add(nil);
                            c += 1;
                        }
                        std::println("Thread:", id, "complete");
                    }, (i,)     
            ));
            i+=1;
        }

        std::println("OK! Waiting to end..");

        i = 0;
        while (i<thread_count)
        {
            do created_threads[i]->wait();
            i+=1;
        }
        std::println("Result:", test_vec->len);
        test_equal(test_vec->len, 100000 * thread_count);

        // Thread should be abort-able..
        let mut this_should_be_false = false;
        let __pack = [mut this_should_be_false];
        let th = thread::create(
            func(mut i: int)
            {
                do __pack[0] = true;
                while (i <= 1_0000_0000)
                {
                    i += 1;
                }
            }, (summ,));
        std::sleep(0.2);
        do th->abort();
        do th->wait();

        test_assure(this_should_be_false == false && summ == 0);

        test_assure(thread::create(\=std::halt("Halt thread for testing.");, ())->wait == false);
        test_assure(thread::create(\=0;, ())->wait == true);
    }
}

test_function("test_thread.main", test_thread::main);
