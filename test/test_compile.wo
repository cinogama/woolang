import woo.std;
import woo.vm;

import test_tool;

namespace test_compile
{
    func compile_program(src: string)=> (bool, std::vm)
    {
        let vmm = std::vm::create();
        let result = vmm->load_source("test_compile/test_tmp_script.wo", src);
        
        return (result, vmm);
    }
    func assure_compile_success(src: string)
    {
        let (success, vm) = compile_program(src);
        if (!success)
            std::println(vm->error_msg());

        test_assure(success);

        vm->close();
    }
    func assure_compile_fail(src: string)
    {
        let (success, vm) = compile_program(src);
        test_assure(!success);
        
        vm->close();
    }

    func main()
    {
        let begin_tm = std::time();
        
        // Empty source will failed.
        assure_compile_fail(@""@);

        // Cannot cast nil
        assure_compile_fail(@"let a = nil: gchandle;"@);

        // Cannot add different types
        assure_compile_fail(@"let b = "" + 2;"@);
        assure_compile_fail(@"let b = 1 + 2.0;"@);
        assure_compile_fail(@"let b = 0x00H + 128;"@);

        // match must walk through all cases
        assure_compile_fail(@"
        union MyUnion
        {
            A,B,C,D,E
        }
        let x = MyUnion::A;
        match(x)
        {
            A?;
            B?;
            C?;
        }
        "@);

        // Invalid match
        assure_compile_fail(@"let m = 1;match(m){ option::value(i)?; }"@);
        assure_compile_fail(@"let m = nil;match(m){ option::none(i)?; }"@);
        assure_compile_fail(@"import woo.std; let m = option::value(1); match(m){ option::none(i)?; }"@);
        assure_compile_fail(@"import woo.std; let m = option::value(1); match(m){ option::value(i)?; option::value(x)?; }"@);
        assure_compile_fail(@"import woo.std; let m = option::value(1); match(m){ option::none(i)?; option::value(x)?; }"@);

        // Construct struct must complete.
        assure_compile_fail(@"
            using st = struct{a: int, b: real};
            st{a = 15};
        "@);
        assure_compile_fail(@"let t = int{a = ""};"@);
        assure_compile_fail(@"let t = y{a = ""};"@);
        assure_compile_fail(@"alias List<T> = (T, List<T>); 0: List<int>;"@); // Not crash!
        assure_compile_fail(@"import woo.std; alias List<T> = option<(T, List<T>)>; 
                              let m = option::none: List<string>;"@); // Not crash!

        // Template args must match
        assure_compile_fail(@"func foo<T,U>(){} foo:<int>();"@);
        assure_compile_fail(@"func foo<T,U>(){} foo:<int, string, real>();"@);

        // extern symbol must be found 
        assure_compile_fail(@"extern("not_exist_func")func foo() => void;"@);
        assure_compile_fail(@"extern("not_exist_lib","not_exist_func")func foo() => void;"@);

        // return must in func
        assure_compile_fail(@"return 0;"@);

        // func cannot return different type if func is not dynamic
        assure_compile_fail(@"func xx(){return 1; return 1.0;}"@);

        // Capture lambda itself is invalid.
        assure_compile_fail(@"func main(){let f = func(){f();};}"@);
        assure_compile_fail(@"func foo<T>(a: T){}func main(){let f = \x: int = foo(f);;}"@);

        // func cannot return different type from marked type
        assure_compile_fail(@"func xx: void(){return 1;}"@);
        assure_compile_fail(@"func xx: int(){return 1.;}"@);
        assure_compile_fail(@"func xx: void(){return 1;}"@);

        // unknown type/identifier is invalid
        assure_compile_fail(@"let x = 1: noexist; let y = x;"@);
        assure_compile_fail(@"let x = 0; y = x;"@);
        assure_compile_fail(@"noexist(1,2,3);"@);

        // Only index struct by const str
        assure_compile_fail(@"
            using st = struct{a: int}; 
            let s = st{a = 1}; 
            let mut i = "a"; 
            let b = s[i];
        "@);

        // Only index struct by const str
        assure_compile_fail(@"
            using st = struct{a: int}; 
            let s = st{a = 1}; 
            let mut i = "a"; 
            let b = s[i];
        "@);
        // immutable member cannot be assign
        assure_compile_fail(@"
            using st = struct{a: int}; 
            let s = st{a = 1}; 
            s.a = 25;
        "@);

          // immutable member cannot be assign
        assure_compile_success(@"
            using st = struct{mut a: int}; 
            let s = st{a = 1}; 
            s.a = 25;
        "@);


        // Cannot index unindexable type or invalid index
        assure_compile_fail(@"let a = 5; let b = a[7];"@);
        assure_compile_fail(@"let a = [1]; let b = a["index"];"@);
        assure_compile_fail(@"
            using st = struct{a: int};
            let s = st{a = 15};
            let b = s.b;
        "@);
        assure_compile_fail(@"
            using st = struct{a: int};
            let s = st{a = 15};
            let b = s[0];
        "@);

        // Call fail
        assure_compile_fail(@"func foo(a:int, let b: string){} foo(1);"@);
        assure_compile_fail(@"func foo(a:int, let b: string){} foo(1., "");"@);
        assure_compile_fail(@"func foo(a:int, let b: string){} foo(1, "", 1);"@);
        assure_compile_fail(@"let a = 1; a();"@);
        assure_compile_fail(@"
            func operator == (a: array<int>, let b: array<int>)=> string{return "Helloworld";}
            let a = 1; let b = (a == 1) as string;
        "@);
        assure_compile_fail(@"
            import woo.co;
            std::co(func(x: int){});
        "@);
        assure_compile_fail(@"
            import woo.co;
            std::co(func(x: int){}, ());
        "@);
        assure_compile_fail(@"
            import woo.co;
            std::co(func(x: int){}, (1, 2, 3));
        "@);
        assure_compile_fail(@"let p<T> = \x: T = x;;p("Helloworld");"@);
        assure_compile_success(@"
            import woo.co;
            std::co(func(){}, ());
        "@);
        assure_compile_success(@"
            import  woo.std;
            let const Invokable<FT, AT> = (std::declval:<FT>())(std::declval:<AT>()) is anything;
            let const Same<A, B> = (std::declval:<A>()) is B;

            func foo<FT, AT>(x: FT, y: AT)
                where Invokable:<FT, AT>,  
                           Same:<AT, int>;
            {
            }

            foo(func(x: int){return x*2}, 2333);
        "@);
        assure_compile_fail(@"
            let const Invokable<FT, AT> = !((nil: dynamic: FT)(nil: dynamic: AT) is pending);
            let const Same<A, B> = (nil: dynamic: A) is B;

            func foo<FT, AT>(x: FT, y: AT)
                where Invokable:<FT, AT>,  
                           Same:<AT, int>;
            {
            }

            foo(func(x: string){}, 2333);
        "@);
        assure_compile_fail(@"
            let const Invokable<FT, AT> = !((nil: dynamic: FT)(nil: dynamic: AT) is pending);
            let const Same<A, B> = (nil: dynamic: A) is B;

            func foo<FT, AT>(x: FT, y: AT)
                where Invokable:<FT, AT>,  
                           Same:<AT, int>;
            {
            }

            foo(func(x: string){}, "Helloworld");
        "@);
        assure_compile_fail(@"
            func foo(x:string){}
            let m = func(){return "fff"};
            foo(m);
        "@);
        assure_compile_fail(@"
            func foo(x:()=>string){}
            foo("Helloworld");
        "@);
        assure_compile_success(@"
            import woo.std;
            let a = option::value(2);
            a->reduce() as option<int>;
        "@);
        assure_compile_success(@"
            import woo.std;
            let a = option::value(option::value(option::value(2)));
            a->reduce() as option<int>;
        "@);
        assure_compile_fail(@"
            import woo.std;
            let a = option::value(option::value(option::value(2)));
            a->reduce() as option<option<int>>;
        "@);

        // Logic op only accept bool
        assure_compile_fail(@"let r = 1 || false;"@);
        assure_compile_fail(@"let r = 1 || 0;"@);
        assure_compile_fail(@"let r = true || 0;"@);
        assure_compile_fail(@"let r = 1 && 0;"@);
        assure_compile_fail(@"let r = 1 && false;"@);
        assure_compile_fail(@"let r = true && 0;"@);
        assure_compile_fail(@"let r = !0;"@);

        // relationship op cannot work at map/array/struct...
        assure_compile_fail(@"let r = [] < [];"@);
        assure_compile_fail(@"let r = {} >= {};"@);
        assure_compile_fail(@"let r = func(){} == [];"@);
        assure_compile_fail(@"union x{a,b}; let r = x::a == x::b;"@);
        assure_compile_success(@"[1,2,3] as array<int>;"@);
        assure_compile_success(@"[1,2,3] is array<int>;"@);
        assure_compile_success(@"[3,2,1] as array<void>;"@);
        assure_compile_success(@"[1,2,3] is array<void>;"@);
        assure_compile_fail(@"[3,2,1] as array<nothing>;"@);
        test_assure([1,2,3] is array<anything>);
        test_assure(!([1,2,3] is array<nothing>));

        // if/while/for only accept bool
        assure_compile_fail(@"if (0){}"@);
        assure_compile_fail(@"while (0){}"@);
        assure_compile_fail(@"for (;0;){}"@);

        // invalid export
        assure_compile_fail(@"extern func foo(){} extern func foo(a:int){}"@);

        // using namespace
        std::vm::virtual_source("test/usingnamespace.wo", @"using std;"@, false);
        assure_compile_fail(@"import woo.std; import test.usingnamespace; println("This should not been displayed!");"@);
        assure_compile_success(@"import woo.std; import test.usingnamespace; using std; println("Helloworld!");"@);

        // redefine
        assure_compile_fail(@"let a = 0; let a = 1;"@);
        assure_compile_fail(@"func a(){} let a = 1;"@);
        assure_compile_fail(@"using a = int; let a = 1;"@);

        // invalid index of tuple
        assure_compile_fail(@"let a = (1,2); a[5] = 6;"@);
        assure_compile_fail(@"let a = (1,2); a[-1] = 6;"@);

        // invalid type of tuple
        assure_compile_fail(@"let a = (1, 3, ["Hello"]); a[2] = [1];"@);
        assure_compile_fail(@"let a = (1, 3, ["Hello"]); a[1] = 1.2;"@);

        // invalid match for tuple
        assure_compile_fail(@"let (a, b) = (1,);"@);
        assure_compile_fail(@"let (a, b) = (1, 2, 3);"@);
        assure_compile_fail(@"import woo.std; match(option::value((1, 2))){option::value((a,))?;option::none?;}"@);
        assure_compile_success(@"import woo.std; match(option::value(1)){option::value(a)?;option::none?;}"@);
        assure_compile_success(@"import woo.std; match(option::value(1)){value(a)?;none?;}"@);
        assure_compile_fail(@"match(option::value(1)){option::value((a,))?;option::none?;}"@);
        assure_compile_fail(@"match(1){value((a,))?;none?;}"@);
    
        assure_compile_fail(@"import woo.std; let const a = []: array<int>; a->add(0);"@);
        assure_compile_fail(@"let i = 0; i += 5;"@);
        assure_compile_fail(@"func foo(x:array<int>){} let const v = []:array<int>; foo(v);"@);
        assure_compile_fail(@"func foo(){let const x = []:array<int>; return x;}"@);

        // constexpr if
        assure_compile_fail(@"let mut a = 2; func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_fail(@"let mut a = 1; func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_success(@"let const a = 1; func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_success(@"let const a = 2; func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_success(@"let const a = 1; let b = a == 1 ? "" | 1; b as string;"@);
        assure_compile_success(@"let const a = 2; let b = a == 1 ? "" | 1; b as int;"@);

        // Type judge
        assure_compile_success(@"
            func foo(){}
            let mut a = 0; let b = a == 1 ? foo() | 1; b as void;"@);
        assure_compile_success(@"
            func foo(){}
            let mut a = 0; let b = a == 1 ? foo() | 1; b as void;"@);
        assure_compile_success(@"
            func foo(){}
            let mut a = 0; let b = a == 1 ? foo() | func(){return func(){};}; b as void;"@);
        assure_compile_success(@"
            import woo.std;
            func foo(){}
            using sp_t = string;
            let v = 
                option::value(0)
                    ->map(\n:int=foo();)
                    ->or(\="":sp_t;);
            "@);
        assure_compile_fail(@"
            import woo.std;
            func foo(f: ((int)=>string)=>int) {}
            foo(std::declval:<(nothing)=>int>());
            "@);
        assure_compile_fail(@"
            import woo.std;
            func foo(f: ((int)=>string)=>int) {}
            foo(std::declval:<((int)=>nothing)=>int>());
            "@);
        assure_compile_success(@"
            import woo.std;
            func foo(f: ((int)=>string)=>int) {}
            foo(std::declval:<((void)=>string)=>int>());
            "@);
        assure_compile_fail(@"
            import woo.std;
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {}
            foo2(std::declval:<((int)=>string)=>(real, string)=>void>());
            "@);
        assure_compile_fail(@"
            import woo.std;
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {}
            foo2(std::declval:<((int)=>string)=>(real, string)=>(void,)>());
            "@);
        assure_compile_fail(@"
            import woo.std;
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {}
            foo2(std::declval:<((int)=>string)=>void>());
            "@);
        assure_compile_success(@"
            import woo.std;
            func foo(f: ((int)=>string)=>int) {}
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {}

            foo(std::declval:<nothing>());
            foo(std::declval:<(void)=>int>());
            foo(std::declval:<((void)=>void)=>int>());
            foo2(std::declval:<nothing>());
            foo2(std::declval:<((int)=>string)=>(real, string)=>(real,)>());
            foo2(std::declval:<((int)=>string)=>(real, string)=>nothing>());
            foo2(std::declval:<((int)=>string)=>nothing>());
            "@);
        assure_compile_success(@"
            import woo.std;

            func assert_type<A, B>()
                where (std::declval:<A>() is B) && (std::declval:<B>() is A);
            {}

            assert_type:<int, int>();   // OK

            let mut a = true;
            assert_type:<typeof(a ? std::declval:<void>() | std::declval:<nothing>()), void>();
            assert_type:<typeof(a ? std::declval:<()=>int>() | std::declval:<()=>void>()), ()=>void>();
            assert_type:<typeof(a ? std::declval:<()=>array<int>>() | std::declval:<()=>void>()), ()=>void>();
            assert_type:<typeof(a ? std::declval:<()=>(array<real>)=>array<int>>() | std::declval:<()=>(array<nothing>)=>void>()), ()=>(array<nothing>)=>void>();     // ERROR RESULT TODO;
            assert_type:<typeof(a ? std::declval:<()=>array<real>>() | std::declval:<()=>array<nothing>>()), ()=>array<real>>();
            assert_type:<typeof(a ? std::declval:<(int)=>void>() | std::declval:<(nothing)=>int>()), (nothing)=>void>();
            assert_type:<typeof(a ? std::declval:<(array<real>)=>void>() | std::declval:<(array<nothing>)=>int>()), (array<nothing>)=>void>();
            "@);

        std::println("Compile 1000 vm!");

        for (let mut i=0; i<1000; i+=1)
        {
            assure_compile_success(@"
                import woo.std;
                func demo<T>(val: T)
                {
                    return "Hello" + val: string;
                }
                func main()
                {
                    demo("world");
                    demo(123);
                    demo(1.72);
                    demo(0x0000H);
                }
            "@);
        }
        let end_time = std::time();
        std::println("Compile 1000 src cost:", end_time - begin_tm);
    }
}

test_function("test_compile.main", test_compile::main);
