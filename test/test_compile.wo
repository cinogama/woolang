import woo::std;
import pkg::vm;

import pkg::thread;

import test_tool;

namespace test_compile
{
    func compile_program(src: string)
    {
        return vm::create("test_compile/test_tmp_script.wo", src: buffer);
    }
    func assure_compile_success(src: string)
    {
        let result = compile_program(src);
        match (result)
        {
        err(msg)?
            {
                std::println(msg);
                test_assure(false);
            }
        ok(vmm)?
            do vmm->close();
        }
    }
    func assure_compile_fail(src: string)
    {
        let result = compile_program(src);
        match (result)
        {
        err(_)?;
        ok(vmm)?
            do vmm->close();
        }

        test_assure(result->is_ok == false);
    }

    func test_compile_success_or_fail()
    {
          // Bad constant
        assure_compile_fail(@"
        let a = '';
        "@);
        assure_compile_fail(@"
        let a = 'abc';
        "@);
        assure_compile_fail(@"
        let a = '你好';
        "@);
        assure_compile_success(@"
        let a = '你';
        "@);
        assure_compile_success(@"
        let a = 'y';
        "@);

        // Empty source will failed.
        assure_compile_fail(@""@);

        // Cannot cast nil
        assure_compile_fail(@"let a = nil: gchandle;"@);

        assure_compile_success(@"
            let a = 5;
            let b = a: string;
            let c = b: void;
        "@);

        assure_compile_fail(@"
            let a = 5;
            let b = a: string;
            let c = b: nothing;
        "@);

        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a: string;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a: int;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a: real;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a as string;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a as int;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a as real;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a is string;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a is int;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a is real;
        "@);

        assure_compile_fail(@"
            let a = nil: dynamic;
            let b = a: nothing;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a: void;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a: bool;
        "@);
        assure_compile_fail(@"
            let a = nil: dynamic;
            let b = a as nothing;
        "@);
        assure_compile_fail(@"
            let a = nil: dynamic;
            let b = a as void;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a as bool; // compile ok, runtime error.
        "@);
        assure_compile_fail(@"
            let a = nil: dynamic;
            let b = a is nothing;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a is void;
        "@);
        assure_compile_success(@"
            let a = nil: dynamic;
            let b = a is bool;
        "@);
        assure_compile_success(@"
            let a = do nil;
            let b = a as void;
        "@);
        assure_compile_fail(@"
            let a = do nil;
            let b = a as void: dynamic;
        "@);

        assure_compile_fail(@"
import woo::std;
let valof<T> = std::declval:<T>();

let issame<A, B> = 
    valof:<A> is B && valof:<B> is A;

alias bool_if_void<T> = 
    typeof(issame:<T, void> ? valof:<bool> | valof:<T>);

alias boom_t = typeof(func(){return 0;});

func main()
{
    let mut px = 233: bool_if_void<boom_t>;
    px = 23;
    do px;
}
        "@);
        assure_compile_fail(@"
import woo::std;
let valof<T> = std::declval:<T>();

let issame<A, B> = 
    valof:<A> is B && valof:<B> is A;

alias bool_if_void<T> = 
    typeof(issame:<T, void> ? valof:<bool> | valof:<T>);

alias boom_t = void;

func main()
{
    let mut px = 233: bool_if_void<boom_t>;
    px = 23;
    do px;
}
        "@);
        assure_compile_success(@"
import woo::std;
let valof<T> = std::declval:<T>();

let issame<A, B> = 
    valof:<A> is B && valof:<B> is A;

alias bool_if_void<T> = 
    typeof(issame:<T, void> ? valof:<bool> | valof:<T>);

alias boom_t = void;

func main()
{
    let mut px = 233: bool_if_void<boom_t>;
    px = false;
    do px;
}
        "@);

        // Cannot add different types
        assure_compile_fail(@"let b = "" + 2;"@);
        assure_compile_fail(@"let b = 1 + 2.0;"@);
        assure_compile_fail(@"let b = 0x00H + 128;"@);

        // match must walk through all cases
        assure_compile_fail(@"
        union MyUnion
        {
            A,B,C,D,E
        }
        let x = MyUnion::A;
        match(x)
        {
            A?;
            B?;
            C?;
        }
        "@);

        // Invalid match
        assure_compile_fail(@"let m = 1;match(m){ option::value(i)?; }"@);
        assure_compile_fail(@"let m = nil;match(m){ option::none(i)?; }"@);
        assure_compile_fail(@"import woo::std; let m = option::value(1); match(m){ option::none(i)?; }"@);
        assure_compile_fail(@"import woo::std; let m = option::value(1); match(m){ option::value(i)?; option::value(x)?; }"@);
        assure_compile_fail(@"import woo::std; let m = option::value(1); match(m){ option::none(i)?; option::value(x)?; }"@);
        assure_compile_fail(@"import woo::std; let m = option::value(1); match(m){ option::none?; option::value?; }"@);

        // Construct struct must complete.
        assure_compile_fail(@"
            using st = struct{a: int, b: real};
            do st{a = 15};
        "@);

        assure_compile_success(@"
            using st = struct{m: array<mut int>};
            do st{m = []};
        "@);
        assure_compile_success(@"
            using st = struct{m: array<int>};
            do st{m = []};
        "@);

        assure_compile_success(@"
            func foo(a){do a;}

            func foo2(f: (int)=>void){do f;}
            
            foo2(foo);
            foo2(foo);
        "@);
        assure_compile_success(@"
            func foo(a){do a;}
            using St = struct{m: (int)=>void};

            func foo2(f: (int)=>void){do f;}
            
            do St{m = foo};
            do St{m = foo};
            foo2(foo);
            foo2(foo);
        "@);

        assure_compile_success(@"
            func foo(a) where a is int; {}
            using St = struct{m: (int)=>void};
            do St{m = foo};
        "@);
        assure_compile_success(@"
            func foo(a) where a is int; {do a;}
            func foo2(f: (int)=>void){do f;}    
            foo2(foo);
        "@);

        assure_compile_fail(@"
            func foo(a) where a is real; {do a;}
            using St = struct{m: (int)=>void};
            do St{m = foo};
        "@);
        assure_compile_fail(@"
            func foo(a) where a is real; {do a;}
            func foo2(f: (int)=>void){do f;}    
            foo2(foo);
        "@);

        assure_compile_fail(@"let t = int{a = ""};"@);
        assure_compile_fail(@"let t = y{a = ""};"@);
        assure_compile_fail(@"alias List<T> = (T, List<T>); do 0: List<int>;"@); // Not crash!
        assure_compile_fail(@"import woo::std; alias List<T> = option<(T, List<T>)>; 
                              let m = option::none: List<string>;"@); // Not crash!

        assure_compile_fail(@"let mut a = \_: int = 0;; a = \n = n;;"@);
        assure_compile_fail(@"let mut a = \_: int = 0;; a = \n: real = n;;"@);
        assure_compile_fail(@"let mut a = \_: int = 0;; a = \n: void = n;;"@);
        assure_compile_success(@"let mut a = \_: int = 0;; a = \n: int = n;;"@);
        assure_compile_success(@"let mut a = []: array<mut (int)=>int>; a[0] = \n: int = n;;"@);
        assure_compile_success(@"let mut a = []: array<mut (int)=>int>; func foo<T>(x: T){return x;} a[0] = foo:<int>;"@);
        assure_compile_fail(@"let mut a = []: array<mut (int)=>int>; func foo<T>(x: T){do x;} a[0] = foo:<int>;"@);

        assure_compile_success(@"using autojudge = struct{f:(int)=>string}; do autojudge{f = \i = i: string;};"@);
        assure_compile_fail(@"using autojudge = struct{f:(int)=>string}; do autojudge{f = \i, x = i: string;};"@);
        assure_compile_fail(@"using autojudge = struct{f:(int)=>string}; do autojudge{f = \i = i: real;};"@);
        assure_compile_fail(@"using autojudge = struct{f:(int)=>string}; do autojudge{f = \ = "";};"@);

        assure_compile_success(@"using autojudget<T, R> = struct{f:(T)=>R}; do autojudget{f = \_: int = "";};"@);
        assure_compile_success(@"using autojudget<T, R> = struct{f:(T)=>R, n: T}; do autojudget{f = \_ = "";, n = 1};"@);
        assure_compile_success(@"using autojudget<T, R> = struct{f:(T)=>R, n: T}; do autojudget{f = \_: int = "";, n = 1};"@);
        assure_compile_fail(@"using autojudget<T, R> = struct{f:(T)=>R, n: T}; do autojudget{f = \_: int = "";, n = 1.25};"@);
        assure_compile_fail(@"using autojudget<T, R> = struct{f:(T)=>R}; do autojudget{f = \_ = "";};"@);

        assure_compile_success(@"using autojudget<T, R> = struct{f:(T)=>R}; do autojudget:<int, string>{f = \_ = "";};"@);
        assure_compile_fail(@"using autojudget<T, R> = struct{f:(T)=>R}; do autojudget:<int>{f = \n = "";};"@);

        assure_compile_success(@"using autojudget<T> = struct{m: T}; do autojudget{m = 2};"@);
        assure_compile_fail(@"using autojudget<T> = struct{m: T}; do autojudget{m = 2}.m = 5;"@);

        assure_compile_success(@"using autojudget<T> = struct{m: T}; do autojudget{m = mut 2};"@);
        assure_compile_success(@"using autojudget<T> = struct{m: T}; do autojudget{m = mut 2}.m = 5;"@);

        assure_compile_success(@"using autojudget<T> = struct{m: mut T, i: T}; do autojudget{m = mut 2, i = 6}.m = 5;"@);
        assure_compile_fail(@"using autojudget<T> = struct{m: mut T, i: T}; do autojudget{m = mut 2, i = 6}.i = 7;"@);

        assure_compile_success(@"using autojudget<T> = struct{m: mut T, i: T}; do autojudget{m = mut 2, i = 6} as autojudget<int>;"@);
        assure_compile_fail(@"using autojudget<T> = struct{m: mut T, i: T}; do autojudget{m = mut 2, i = 6} as autojudget<mut int>;"@);

        // Template args must match
        assure_compile_fail(@"func foo<T,U>(){} foo:<int>();"@);
        assure_compile_fail(@"func foo<T,U>(){} foo:<int, string, real>();"@);
        assure_compile_fail(@"func foo<T,U>(){} foo();"@);
        assure_compile_fail(@"let p<T> = 0; do p;"@);
        assure_compile_success(@"let p<T> = 0; do p:<int>;"@);
        assure_compile_fail(@"func p<T>(){} do p;"@);
        assure_compile_success(@"func p<T>(){} do p:<int>;"@);

        assure_compile_fail(@"func foo(){let fv = \=kv;; let kv = 0; do fv; do kv;};"@);
        assure_compile_fail(@"func foo(){let kv = 0; let fv = \=kv;;};"@);
        assure_compile_success(@"func foo(){let kv = 0; let fv = \=kv;;do fv;};"@);
        assure_compile_fail(@"func foo(){let fv = \=kv;; let mut kv = 0;do fv; do kv;};"@);
        assure_compile_success(@"func foo(){let mut kv = 0; let fv = \=kv;;do fv;};"@);

        // extern symbol must be found 
        assure_compile_fail(@"extern("not_exist_func")func foo() => void;"@);
        assure_compile_fail(@"extern("not_exist_lib","not_exist_func")func foo() => void;"@);

        // return can in func or in global
        assure_compile_success(@"namespace example {return 0;}"@);
        assure_compile_success(@"return 0;"@);

        // func cannot return different type if func is not dynamic
        assure_compile_fail(@"func xx(){return 1; return 1.0;}"@);

        // Capture lambda itself is invalid.
        assure_compile_fail(@"func main(){let f = func(){f();};}"@);
        assure_compile_fail(@"func foo<T>(a: T){}func main(){let f = \x: int = foo(f);;}"@);

        // Can capture template variable now.
        assure_compile_success(@"func main(){let t<T> = 0;return func(){return t:<int>;};}"@);

        // func cannot return different type from marked type
        assure_compile_fail(@"func xx()=> string{return;}"@);
        assure_compile_fail(@"func xx()=> int{return 1.;}"@);
        assure_compile_fail(@"func xx()=> real{return 1;}"@);

        assure_compile_fail(@"func xx()
            {
                return 1;
                return mut 1;
            }"@);
        assure_compile_fail(@"func xx()
            {
                return mut 1;
                return 1;
            }"@);
        assure_compile_success(@"func xx()
            {
                return mut 1;
                return mut 1;
            }"@);
        assure_compile_success(@"func xx()
            {
                return 1;
                return 1;
            }"@);
        assure_compile_fail(@"func xx()
            {
                return mut 1;
            }
            let p = [xx()];
            p[0] = 1;
            "@);
        assure_compile_success(@"
            import woo::std;

            let a = [1,2,3]->>\n=mut n;;
            a[0] = 6;
            "@);
        assure_compile_fail(@"
            import woo::std;

            let a = [1,2,3]->>\n=n;;
            a[0] = 6;
            "@);

        // unknown type/identifier is invalid
        assure_compile_fail(@"let x = 1: noexist; let y = x;"@);
        assure_compile_fail(@"let x = 0; y = x;"@);
        assure_compile_fail(@"noexist(1,2,3);"@);

        // Only index struct by const str
        assure_compile_fail(@"
            using st = struct{a: int}; 
            let s = st{a = 1}; 
            let mut i = "a"; 
            let b = s[i];
        "@);

        assure_compile_success(@"
            using st = struct{a: int}; 
            let s = st{a = 1}; 
            let i = "a"; 
            let b = s[i];
        "@);

        assure_compile_success(@"
            import woo::std;
            using List<T> = struct{
                e: T,
                next: option<List<T>>,
            };
            let a = List:<string>{e = "Hello", next = option::none};
        "@);

        assure_compile_success(@"
            import woo::std;
            using List<T> = struct{
                e: T,
                next: option<List<T>>,
            };
            let a = List{e = "Hello", next = option::none};
        "@);
        
        // immutable member cannot be assign
        assure_compile_fail(@"
            using st = struct{a: int}; 
            let s = st{a = 1}; 
            s.a = 25;
        "@);
        assure_compile_fail(@"
            using st = struct{a: mut int}; 
            let s = st{a = 1}; 
            s.a = 25;
        "@);
        assure_compile_success(@"
            using st = struct{a: mut int}; 
            let s = st{a = mut 1}; 
            s.a = 25;
        "@);

        assure_compile_success(@"
            let mut dd = 0;

            union result<T, F>
            {
                ok(T), err(F)
            }

            let mut opt = \_: void = 
                dd == 1
                ? result::ok(233.5): result<real, string>
                | result::err("fuck"): result<real, string>
                ;
            ;

            opt = \_: void = result::ok(3.14); as (void)=>result<real, string>;
        "@);

        // Cannot index unindexable type or invalid index
        assure_compile_fail(@"let a = 5; let b = a[7];"@);
        assure_compile_fail(@"let a = [1]; let b = a["index"];"@);
        assure_compile_fail(@"
            using st = struct{a: int};
            let s = st{a = 15};
            let b = s.b;
        "@);
        assure_compile_fail(@"
            using st = struct{a: int};
            let s = st{a = 15};
            let b = s[0];
        "@);

        // Call fail
        assure_compile_fail(@"func foo(a:int, b: string){} foo(1);"@);
        assure_compile_fail(@"func foo(a:int, b: string){} foo(1., "");"@);
        assure_compile_fail(@"func foo(a:int, b: string){} foo(1, "", 1);"@);
        assure_compile_fail(@"let a = 1; a();"@);
        assure_compile_fail(@"
            namespace array
            {
                func operator == (_: array<int>, _: array<int>)=> string{
                    return "Helloworld";}
            }
            let a = 1; let b = (a == 1) as string;
        "@);
        assure_compile_success(@"
            namespace array
            {
                func operator == (_: array<int>, _: array<int>)=> string{
                    return "Helloworld";}
            }
            let a = [1]; let b = (a == [1]) as string;
        "@);
        assure_compile_fail(@"
            func foo<Ft, ArgTs>(f: Ft, args: ArgTs) where f(args...) is void;{}
            foo(func(x: int){});
        "@);
        assure_compile_fail(@"
            func foo<Ft, ArgTs>(f: Ft, args: ArgTs) where f(args...) is void;{}
            foo(func(x: int){}, ());
        "@);
        assure_compile_fail(@"
            func foo<Ft, ArgTs>(f: Ft, args: ArgTs) where f(args...) is void;{}
            foo(func(x: int){}, (1, 2, 3));
        "@);
        assure_compile_fail(@"let p<T> = \x: T = x;;p("Helloworld");"@);
        assure_compile_success(@"
            func foo<Ft, ArgTs>(f: Ft, args: ArgTs) where f(args...) is void;{}
            foo(func(){}, ());
        "@);
        assure_compile_fail(@"
            func foo<Ft, ArgTs>(f: Ft, args: ArgTs) where f(args...) is void;{}
            foo(func(){return nil;}, ());
        "@);
        assure_compile_success(@"
            import woo::std;
            let Invokable<FT, AT> = std::declval:<FT>()(std::declval:<AT>()) is void;
            let Same<A, B> = (std::declval:<A>()) is B;

            func foo<FT, AT>(_: FT, _: AT)
                where Invokable:<FT, AT>,  
                           Same:<AT, int>;
            {
            }

            foo(func(x: int){do x;}, 2333);
        "@);
        assure_compile_fail(@"
            import woo::std;
            let Invokable<FT, AT> = std::declval:<FT>()(std::declval:<AT>()) is void;
            let Same<A, B> = std::declval:<A>() is B;

            func foo<FT, AT>(_: FT, _: AT)
                where Invokable:<FT, AT>,  
                           Same:<AT, int>;
            {
            }

            foo(func(x: string){do x;}, 2333);
        "@);
        assure_compile_fail(@"
            import woo::std;
            let Invokable<FT, AT> = std::declval:<FT>()(std::declval:<AT>()) is void;
            let Same<A, B> = std::declval:<A>() is B;

            func foo<FT, AT>(_: FT, _: AT)
                where Invokable:<FT, AT>,  
                           Same:<AT, int>;
            {
            }

            foo(func(x: string){do x;}, "Helloworld");
        "@);
        assure_compile_success(@"
            let x = typeid:<typeof(std::declval:<nothing>())>;
        "@);
        assure_compile_success(@"
            let x = typeid:<typeof(std::declval:<pending>())>;
        "@);
        assure_compile_success(@"
            let x = typeid:<typeof(fooexist())>;
        "@);
        assure_compile_fail(@"
            func foo(x:string){}
            let m = func(){return "fff"};
            foo(m);
        "@);
        assure_compile_fail(@"
            func foo(x:()=>string){}
            foo("Helloworld");
        "@);
        assure_compile_success(@"
            import woo::std;
            let a = option::value(2);
            do a as option<int>;
        "@);
        assure_compile_success(@"
            import woo::std;
            let a = option::value(option::value(option::value(2)));
            do a=>>\elem = elem;=>>\elem = elem; as option<int>;
        "@);
        assure_compile_fail(@"
            import woo::std;
            let a = option::value(option::value(option::value(2)));
            do a=>>\elem = elem;=>>\elem = elem; as option<option<int>>;
        "@);

        // Logic op only accept bool
        assure_compile_fail(@"let r = 1 || false;"@);
        assure_compile_fail(@"let r = 1 || 0;"@);
        assure_compile_fail(@"let r = true || 0;"@);
        assure_compile_fail(@"let r = 1 && 0;"@);
        assure_compile_fail(@"let r = 1 && false;"@);
        assure_compile_fail(@"let r = true && 0;"@);
        assure_compile_fail(@"let r = !0;"@);

        // relationship op cannot work at dict/array/struct...
        assure_compile_fail(@"let r = [] < [];"@);
        assure_compile_fail(@"let r = {} >= {};"@);
        assure_compile_fail(@"let r = func(){} == [];"@);
        assure_compile_fail(@"union x{a,b}; let r = x::a == x::b;"@);
        assure_compile_success(@"do [1,2,3] as array<int>;"@);
        assure_compile_success(@"do [1,2,3] is array<int>;"@);
        assure_compile_fail(@"do [3,2,1] as array<void>;"@);
        assure_compile_success(@"do [1,2,3] is array<void>;"@);
        assure_compile_fail(@"do [3,2,1] as array<nothing>;"@);
        test_assure([1,2,3] is array<void> == false);
        test_assure(!([1,2,3] is array<nothing>));

        // if/while/for only accept bool
        assure_compile_fail(@"if (0){}"@);
        assure_compile_fail(@"while (0){}"@);
        assure_compile_fail(@"for (;0;){}"@);

        // invalid export
        assure_compile_fail(@"extern func foo(){} extern func foo(a:int){}"@);

        // using namespace
        do vm::create_virtual_script("test/usingnamespace.wo", @"using std;"@, false);
        assure_compile_fail(@"import woo::std; import test::usingnamespace; println("This should not been displayed!");"@);
        assure_compile_success(@"import woo::std; import test::usingnamespace; using std; println("Helloworld!");"@);

        // redefine
        assure_compile_fail(@"let a = 0; let a = 1;"@);
        assure_compile_fail(@"func a(){} let a = 1;"@);
        assure_compile_fail(@"using a = int; let a = 1;"@);
        assure_compile_fail(@"let a = 1; using a = int;"@);
        assure_compile_fail(@"using a = int; using a = real;"@);

        // invalid index of tuple
        assure_compile_fail(@"let a = (1,2); a[5] = 6;"@);
        assure_compile_fail(@"let a = (1,2); a[-1] = 6;"@);

        // invalid type of tuple
        assure_compile_fail(@"let a = (1, 3, ["Hello"]); a[2] = [1];"@);
        assure_compile_fail(@"let a = (1, 3, ["Hello"]); a[1] = 1.2;"@);

        // invalid match for tuple
        assure_compile_fail(@"let (a, b) = (1,);"@);
        assure_compile_fail(@"let (a, ref b) = (1, 2);"@);
        assure_compile_fail(@"let (ref a, ref b) = (1, mut 2);"@);
        assure_compile_fail(@"let (a, b) = (1, 2, 3);"@);
        assure_compile_fail(@"import woo::std; match(option::value((1, 2))){option::value((a,))?;option::none?;}"@);
        assure_compile_success(@"
            import woo::std; 
            let m = option::value(1);
            match(m)
            { 
                none?; 
                value(n)?
                    std::println(n); 
            }
        "@);

        assure_compile_success(@"
            union Test
            {
                A(int),
                B(int),
                C(int),
            }

            match(Test::A(3))
            { 
                A(n)?; 
                _?; 
            }
        "@);

        assure_compile_success(@"
            union Test<T>
            {
                A(T),
                B(T),
                C(T),
            }

            match(Test::A(3))
            { 
                A(n)?; 
                _?; 
            }
        "@);

        assure_compile_success(@"
            union Test
            {
                A(int),
                B(int),
                C(int),
            }

            match(Test::A(3))
            { 
                _?; 
            }
        "@);

        assure_compile_success(@"
            union Test<T>
            {
                A(T),
                B(T),
                C(T),
            }

            match(Test::A(3))
            { 
                _?; 
            }
        "@);

        assure_compile_success(@"
            union Test
            {
                A(int),
                B(int),
                C(int),
            }

            match(Test::A(3))
            { 
                A(n)?; 
                B(n)?;
                _?; 
            }
        "@);

        assure_compile_success(@"
            union Test
            {
                A(int),
                B(int),
                C(int),
            }

            match(Test::A(3))
            { 
                A(n)?; 
                B(n)?;
                C(n)?;
                _?; 
            }
        "@);

        assure_compile_fail(@"
            union Test
            {
                A(int),
                B(int),
                C(int),
            }

            match(Test::A(3))
            { 
                A(n)?; 
                A(n)?; 
                A(n)?; 
            }
        "@);

        assure_compile_fail(@"
            union Test
            {
                A(int),
                B(int),
                C(int),
            }

            match(Test::A(3))
            { 
                _?;
                C(n)?; 
            }
        "@);

        assure_compile_fail(@"
            union Test<T>
            {
                A(T),
                B(T),
                C(T),
            }

            match(Test::A(3))
            { 
                _?;
                C(n)?; 
            }
        "@);
        
        // Issue N221109: ref has been removed.
        assure_compile_success(@"let (a, b) = (1, mut 2);"@);
        assure_compile_fail(@"let (a, b) = (1, mut 2); a = 2;"@);
        assure_compile_success(@"import woo::std; match(option::value(1)){value(a)?;none?;}"@);
        assure_compile_success(@"import woo::std; match(option::value(1)){value(a)?;none?;}"@);
        assure_compile_fail(@"match(option::value(1)){option::value((a,))?;option::none?;}"@);
        assure_compile_fail(@"match(1){value((a,))?;none?;}"@);
    
        assure_compile_fail(@"import woo::std; let a = []: array<int>; a->add(0);"@);
        assure_compile_fail(@"let i = 0; i += 5;"@);
        assure_compile_fail(@"func foo(x:vec<int>){} let v = []:array<int>; foo(v);"@);

        // constexpr if
        assure_compile_fail(@"let mut a = 2; do func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_fail(@"let mut a = 1; do func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_success(@"let a = 1; do func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_success(@"let a = 2; do func(){if(a == 1)return "";else return 1;};"@);
        assure_compile_success(@"let a = 1; let b = a == 1 ? "" | 1; do b as string;"@);
        assure_compile_success(@"let a = 2; let b = a == 1 ? "" | 1; do b as int;"@);

        // Type judge
        assure_compile_success(@"
            func foo(){}
            let mut a = 0; let b = a == 1 ? foo() | 1: void; do b as void;"@);
        assure_compile_success(@"
            func foo(){}
            let mut a = 0; let b = a == 1 ? foo() | 1: void; do b as void;"@);
        assure_compile_success(@"
            func foo(){}
            let mut a = 0; let b = a == 1 ? foo() | func(){return func(){};}: void; do b as void;"@);
        assure_compile_fail(@"
            import woo::std;
            func foo(){}
            using sp_t = string;
            let v = 
                option::value(0)
                    ->map(\_:int=foo();)
                    ->or_do(\="":sp_t;);
            "@);
            assure_compile_success(@"
            import woo::std;
            func foo(){}

            let v = 
                option::value(0)
                    ->map(\_:int=foo();)
                    ->or_do(\=do "";);
            "@);
        assure_compile_fail(@"
            import woo::std;
            func foo(f: ((int)=>string)=>int) {do f;}
            foo(std::declval:<(nothing)=>int>());
            "@);
        assure_compile_fail(@"
            import woo::std;
            func foo(f: ((int)=>string)=>int) {do f;}
            foo(std::declval:<((int)=>nothing)=>int>());
            "@);
        assure_compile_fail(@"
            import woo::std;
            func foo(f: ((int)=>string)=>int) {do f;}
            foo(std::declval:<((void)=>string)=>int>());
            "@);
        assure_compile_success(@"
            import woo::std;
            func foo(f: ((int)=>string)=>int) {do f;}
            foo(std::declval:<((int)=>string)=>int>());
            "@);
        assure_compile_fail(@"
            import woo::std;
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {do f;}
            foo2(std::declval:<((int)=>string)=>(real, string)=>void>());
            "@);
        assure_compile_fail(@"
            import woo::std;
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {do f;}
            foo2(std::declval:<((int)=>string)=>(real, string)=>(void,)>());
            "@);
        assure_compile_fail(@"
            import woo::std;
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {do f;}
            foo2(std::declval:<((int)=>string)=>void>());
            "@);
        assure_compile_success(@"
            import woo::std;
            func foo(f: ((int)=>string)=>int) {do f;}
            func foo2(f: ((int)=>string)=>(real, string)=>(real,)) {do f;}

            foo(std::declval:<nothing>());
            foo2(std::declval:<nothing>());
            foo2(std::declval:<((int)=>string)=>(real, string)=>(real,)>());
            foo2(std::declval:<((int)=>string)=>(real, string)=>nothing>());
            foo2(std::declval:<((int)=>string)=>nothing>());
            "@);
        assure_compile_success(@"
            import woo::std;

            func assert_type<A, B>()
                where (std::declval:<A>() is B) && (std::declval:<B>() is A);
            {}

            assert_type:<int, int>();   // OK

            let mut a = true;
            assert_type:<typeof(a ? std::declval:<void>() | std::declval:<nothing>()), void>();
            assert_type:<typeof(a ? std::declval:<()=>array<real>>() | std::declval:<()=>array<nothing>>()), ()=>array<real>>();
            "@);

        // array/dict is not modifiable
        assure_compile_fail(@"
            let a = [1,2,3];
            a[0] = 6;
        "@);
        assure_compile_fail(@"
            let a = {[0] = 1};
            a[0] = 6;
        "@);
        // vec/map can be modified;
        assure_compile_success(@"
            let a = [mut 1, mut 2,mut 3];
            let b = {[0] = mut 1};
            
            a[0] = 6;
            b[0] = 6;
        "@);
        
        assure_compile_fail(@"
            namespace prot
            {
                protected func foo(){}
            }
            foo();
        "@);

        assure_compile_success(@"
            import woo::std;
            for (let b : [mut "Hello"])
                std::println(F"{b}");
        "@);

        assure_compile_success(@"
            import woo::std;
            let t = (mut 1, mut "Hello");
            let (a, b) = t;
            std::println(F"{b}");
        "@);

        assure_compile_success(@"
            import woo::std;
            do [mut "Hello"]->>\s=F"{s}";;
        "@);

        assure_compile_success(@"
            import woo::std;
            let o = option::value(mut "Hello");
            match (o)
            {
            value(b)?
                std::println(F"{b}");
            none?;
            }
           
        "@);

        assure_compile_success(@"
            using st<T> = struct{a: T}; 
            using st2<F> = struct{b: st:<F>, c: st<F>}; // Both :< & < in type is valid.

            let x = st:<string>{a = "abc" };
            let y = st2:<string>{b = x, c = x};
        "@);

        // 
        assure_compile_fail(@"
            import woo::std;

            func main()
            {
                func f(){};
                func f(){};
            }
            "@);
        assure_compile_success(@"
            import woo::std;

            func main()
            {
                func f(){};
                {
                    func f(){};
                    do f;
                }
                do f;
            }
            "@);
        assure_compile_fail(@"
            import woo::std;

            func main()
            {
                func f(){func f(){};};
            }
            "@);

        // 
        assure_compile_fail(@"
            import woo::std;

            func main(_: int)
            {
            }
            main("Helloworld");
            "@);

        assure_compile_success(@"
            import woo::std;

            func main(_: int)
            {
            }
            main(25);
            "@);
        
        assure_compile_success(@"
            import woo::std;

            func main(_: int, _: real)
            {
            }
            main(25, 6.25);
            "@);

        assure_compile_success(@"
            import woo::std;

            let _ = 5;
            "@);
        assure_compile_success(@"
            import woo::std;

            let _<T> = 5;
            "@);
        assure_compile_fail(@"
            import woo::std;

            let (a, b)<T> = (5, 6);
            "@);
        
        //  
        assure_compile_success(@"
            func foo(mut _: int){}
            func foo2(mut _: int){}
            let mut a = foo;
            a = foo2;
            "@);
        
        assure_compile_fail(@"
            func foo(_: mut int){}
            func foo2(mut _: int){}
            let mut a = foo;
            a = foo2;
            "@);

        assure_compile_success(@"
            func foo(_: mut int){}
            func foo2(_: mut int){}
            let mut a = foo;
            a = foo2;
            "@);

        assure_compile_success(@"
            using E = struct{a : mut string};
            do E{a = mut 1: string};
            "@);

        //
        assure_compile_fail(@"
            func main(a : mut int)
            {
                a = 5;
                do a;
            }
            "@);
        assure_compile_success(@"
            func main(mut a : int)
            {
                a = 5;
                do a;
            }
            "@);
        assure_compile_success(@"
            func main(mut a : mut int)
            {
                a = 5;
                do a;
            }
            "@);
        assure_compile_success(@"
            namespace aaa
            {
                protected using example_t = int;
                public func foo()
                {
                    return 0: example_t;
                }
            }
            let a = aaa::foo() as aaa::example_t;
            "@);
        assure_compile_fail(@"
            namespace aaa
            {
                protected using example_t = int;
                public func foo()
                {
                    return 0: example_t;
                }
            }
            let a = aaa::foo(): aaa::example_t;
            "@);
        assure_compile_fail(@"
            namespace aaa
            {
                protected using example_t = int;
                public func foo()
                {
                    return 0: example_t;
                }
            }
            let a = 0: aaa::example_t;
            "@);

        assure_compile_success(@"
            namespace aaa
            {
                protected using example_t = struct{_: void};
                public func foo()
                {
                    return example_t{_ = do nil};
                }
            }
            let a = aaa::foo() as aaa::example_t;
            "@);
        assure_compile_fail(@"
            namespace aaa
            {
                protected using example_t = struct{_: void};
                public func foo()
                {
                    return example_t{_ = do nil};
                }
            }
            let a = aaa::example_t{_ = do nil};
            "@);
        assure_compile_fail(@"
            namespace aaa
            {
                protected using example_t = struct{_: void};
                public func foo()
                {
                    return example_t{_ = do nil};
                }
            }
            let a = struct{_ = do nil}: aaa::example_t;
            "@);
        assure_compile_success(@"
            namespace aaa
            {
                using example_t = struct{_: void};
                public func foo()
                {
                    return example_t{_ = do nil};
                }
            }
            let a = struct{_ = do nil}: aaa::example_t;
            "@);

        assure_compile_success(@"
            import woo::std;
            using RecursiveT = (RecursiveT, void);
            do option::none: option<RecursiveT>;
            "@);
        assure_compile_success(@"
            import woo::std;
            using RecursiveT = (void, RecursiveT);
            do option::none: option<RecursiveT>;
            "@);
        assure_compile_success(@"
            import woo::std;
            using RecursiveT = (RecursiveT, RecursiveT);
            do option::none: option<RecursiveT>;
            "@);

        assure_compile_success(@"
            let v = [];
            "@);
        assure_compile_success(@"
            let v = []: array<int>;
            "@);
        assure_compile_fail(@"
            let v = []: array<>;
            "@);
        assure_compile_fail(@"
            let v = []: array;
            "@);
        assure_compile_success(@"
            let v = {};
            "@);
        assure_compile_success(@"
            let v = {}: dict<int, int>;
            "@);
        assure_compile_fail(@"
            let v = []: dict<>;
            "@);
        assure_compile_fail(@"
            let v = []: dict<int>;
            "@);
        assure_compile_fail(@"
            let v = []: dict;
            "@);

        assure_compile_success(@"
            alias A<T> = struct{a: T<int>};
            let a = []: array<A<array<nothing>>>;
            "@);
        assure_compile_fail(@"
            alias A<T> = struct{a: T<int>};
            let a = []: array<A<int>>;
            "@);

        assure_compile_fail(@"
            import woo::std;
            let a = option::value(nil: dynamic)
                =>> \e = e is T? option::value(e as T) | option::none;
                ;
            "@);
        assure_compile_success(@"
            import woo::std;
            func foo<T>()
            {
                let a = option::value(nil: dynamic)
                    =>> \e = e is T? option::value(e as T) | option::none;
                    ;
                do a as option<int>;
            }
            foo:<int>();
            "@);
        assure_compile_success(@"
            import woo::std;
            func foo<T>()
            {
                let a = option::value(nil: dynamic)
                    =>> \e = e is T? option::value(e as T) | option::none;
                    ;
                do a as option<string>;
            }
            foo:<string>();
            "@);
        assure_compile_fail(@"
            import woo::std;
            func foo<T>()
            {
                let a = option::value(nil: dynamic)
                    =>> \e = e is T? option::value(e as T) | option::none;
                    ;
                do a as option<string>;
            }
            foo:<int>();
            "@);

         assure_compile_success(@"
            namespace Aaa
            {
                using Aba<T> = T;
                func foo<T>(_: T, _: (Aba<T>)=> void)
                {

                }
                func bar(_: string, _: (Aba<string>)=> void)
                {

                }
                using Att<T> = struct{a : ()=> Aba<T>};
                using Ati = struct{a : ()=> Aba<int>};
                using Atfi = struct{a : (Aba<int>)=> void};
            }

            Aaa::foo(6, func(n){do n;});
            Aaa::bar("", func(n){do n;});
            do Aaa::Att{a = \=0: Aaa::Aba<int>;};
            do Aaa::Att{a = \="Helloworld": Aaa::Aba<string>;};
            do Aaa::Ati{a = \=0: Aaa::Aba<int>;};
            do Aaa::Atfi{a = \_=do nil;};
            "@);

        assure_compile_success(@"
            using a = struct {a: mut (int)=>nil};
            do a{a = mut \_=nil;};
            "@);
        assure_compile_fail(@"
            using a = struct {a: mut (int)=>nil};
            do a{a = mut \_,_=nil;};
            "@);
        assure_compile_success(@"
            func foo(_: mut (int)=>void){}
            foo(\_=do nil;);
            "@);
        assure_compile_fail(@"
            func foo(_: mut (int)=>void){}
            foo(\_, _=do nil;);
            "@);
        
        assure_compile_fail(@"
            func foo()=> mut int{return 0;}
            "@);
        assure_compile_fail(@"
            func foo()=> int{return mut 0;}
            "@);
        assure_compile_success(@"
            func foo()=> mut int{return mut 0;}
            "@);
        assure_compile_success(@"
            func foo()=> int{return 0;}
            "@);

        assure_compile_fail(@"
            #macro AAA{return "";}
            AAA;
            "@);
        assure_compile_success(@"
            #macro AAA{return "";}
            AAA!;
            "@);
        assure_compile_fail(@"
            #macro AAA{return "";
            "@);

        assure_compile_fail(@"
            let a = [];
            do a.aaa;
            "@);
        assure_compile_success(@"
            let a = (0, 1);
            do a.1;
            "@);

        assure_compile_fail(@"
            let a = (0, 1);
            do a.2;
            "@);

        assure_compile_success(@"
            let a = (0, 1);
            do a.0;
            "@);

        assure_compile_fail(@"
            let a = (0, 1);
            do a.0.0;
            "@);

        assure_compile_success(@"
            import woo::std;
            using option;
            using result;
            do option::value(do nil)->> \p = p;;
            "@);

        assure_compile_fail(@"
            namespace function
            {
                func foo(_: ()=> int)
                {

                }
            }

            let f = \n: int = do nil;;
            f->foo;
        "@);
        assure_compile_success(@"
            namespace function
            {
                func foo(_: ()=> int)
                {

                }
            }

            let f = \ = 6;;
            f->foo;
        "@);
        assure_compile_fail(@"
            using function = int;
        "@);
        assure_compile_fail(@"
            enum function
            {
                a = 5,
            }
        "@);
        assure_compile_success(@"
            using AA = struct{protected __m: int};
            let a = AA{__m = 5};
        "@);
        assure_compile_success(@"
            using AA = struct{protected __m: int};
            let a = struct{__m = 5}: AA;
        "@);
        assure_compile_success(@"
            using AA = struct{__m: int};
            let a = AA{__m = 5};
        "@);
        assure_compile_success(@"
            using AA = struct{public __m: int};
            let a = AA{__m = 5};
        "@);
        assure_compile_success(@"
            using AA = struct{protected __m: int}
            {
                public func create()
                {
                    return AA{__m = 5};
                }
            }
            let a = AA::create();
        "@);
        assure_compile_fail(@"
            namespace DDD
            {
                using AA = struct{protected __m: int}
                {
                    public func create()
                    {
                        return AA{__m = 5};
                    }
                }
            }
            let a = DDD::AA::create();

            do a.__m;
        "@);
        assure_compile_success(@"
            namespace DDD
            {
                using AA = struct{protected __m: int}
                {
                    public func create()
                    {
                        return AA{__m = 5};
                    }
                }
            }
            let a = DDD::AA::create();

            namespace DDD
            {
                do a.__m;
            }
        "@);
        assure_compile_fail(@"
            namespace DDD
            {
                using AA = struct{protected __m: int}
                {
                    using AA = int;
                    public func create()
                    {
                        return AA{__m = 5};
                    }
                }
            }
            let a = DDD::AA::create();

            do a.__m;
        "@);

        assure_compile_success(@"
            using AA = struct{protected __m: int}
            {
                using AA = real;
                public func create()
                {
                    return BB{__m = 5};
                }
            }

            alias BB = AA;

            let a = AA::create(): BB: AA;
        "@);
        assure_compile_fail(@"
            namespace DDD
            {
                using AA = struct{protected __m: int}
                {
                    using AA = real;
                    public func create()
                    {
                        return BB{__m = 5};
                    }
                }
            }
            alias BB = DDD::AA;

            let a = DDD::AA::create(): DDD::AA: BB;

            do a.__m;
        "@);
        assure_compile_fail(@"
            namespace DDD
            {
                using AA = struct{protected __m: int}
                {
                    using AA = real;
                    public func create()
                    {
                        return BB{__m = 5};
                    }
                }
            }

            alias BB = DDD::AA;

            let a = DDD::AA::create(): DDD::AA: BB: DDD::AA;

            namespace BB
            {
                do a.__m;
            }
        "@);
        assure_compile_success(@"
            namespace DDD
            {
                using AA = struct{protected __m: int}
                {
                    using AA = real;
                    public func create()
                    {
                        return BB{__m = 5};
                    }
                }
            }

            alias BB = DDD::AA;

            let a = DDD::AA::create(): DDD::AA: BB: DDD::AA;

            namespace DDD
            {
                do a.__m;
            }
        "@);
        assure_compile_success(@"
            using AA = struct{protected __m: int}
            {
                using AA = real;
                public func create()
                {
                    return BB{__m = 5};
                }
            }

            alias BB = AA;

            let a = AA::create(): AA: BB: AA;

            do a.__m;
        "@);
        assure_compile_success(@"
            using AA = struct{protected __m: int}
            {
                using AA = real;
                public func create()
                {
                    return BB{__m = 5};
                }
            }

            alias BB = AA;

            let a = AA::create(): AA: BB: AA;

            namespace BB
            {
                do a.__m;
            }
        "@);
        assure_compile_success(@"
            using AA = struct{protected __m: int}
            {
                using AA = real;
                public func create()
                {
                    return BB{__m = 5};
                }
            }

            alias BB = AA;

            let a = AA::create(): AA: BB: AA;

            namespace AA
            {
                do a.__m;
            }
        "@);

        assure_compile_success(@"
        namespace Example
        {
            let x = struct{__m = 0};
            do x.__m;
        }
        "@);
        assure_compile_success(@"
        namespace Example
        {
            let x = struct{__m = 0};
        }
        do Example::x.__m;
        "@);

        assure_compile_success(@"
        func foo()
        {
            let a = struct{__m = 0};
            do a.__m;
            return a;
        }
        "@);
        assure_compile_success(@"
        func foo()
        {
            let a = struct{__m = 0};
            do a.__m;
            return a;
        }
        do foo().__m;
        "@);

        assure_compile_success(@"
        extern func foo(){}
        "@);
        assure_compile_success(@"
        extern func foo(_){}
        "@);

        assure_compile_success(@"
        import woo::std;

        using aa = void
        {
            alias test<T> = typeof(std::declval:<T>()->foo);
        }

        namespace xxx
        {
            using aa<T> = void
            {
                func foo<T>(_: aa<T>){}
            }
        }

        let a = nil: aa::test<xxx::aa<string>>;
        "@);

        assure_compile_success(@"
        using aa = void
        {
            alias test<T> = typeof:<T>::ut;

            alias ut = real;
        }

        namespace xxx
        {
            using aa<T> = void
            {
                alias ut = void;
            }
        }

        let a = nil: aa::test<xxx::aa<string>>;
        "@);

        assure_compile_fail(@"
        using aa = void
        {
            alias test<T> = typeof:<T>::ut;

            alias ut = real;
        }

        namespace xxx
        {
            using aa<T> = void
            {
                alias ut = int;
            }
        }

        let a = nil: aa::test<xxx::aa<string>>;
        "@);

        assure_compile_success(@"
        using aa = void
        {
            alias test<T> = typeof:<T>::ut;

            alias bx = real;
        }

        namespace xxx
        {
            using aa<T> = void
            {
                alias ut = bx;
                alias bx = void;
            }
        }

        let a = nil: aa::test<xxx::aa<string>>;
        "@);

        assure_compile_success(@"
        using aa = void
        {
            alias test<T> = typeof(typeof:<T>::bk:<T>);

            let bk = 0;
        }

        namespace xxx
        {
            using aa<T> = void
            {
                let bk<T> = nil;
            }
        }

        let a = nil: aa::test<xxx::aa<string>>;
        "@);

        assure_compile_fail(@"
            union example{val(int)}
            let a = [][0]: example;
            do a.val;
        "@);
        assure_compile_success(@"
            using example = struct {val: int};
            let a = [][0]: example;
            do a.val;
        "@);

        assure_compile_success(@"
        import woo::std;

        func foo<T>(_)=> option<T>
        {
            return option::none: option<T>;
        }

        do func(_: (int)=>option<int>){}(foo);
        "@);

        assure_compile_success(@"
        import woo::std;

        namespace fxx
        {
            func foo<T>(_)=> option<T>
            {
                return ::option::none: option<T>;
            }
        }
        do func(_: (int)=>option<int>){}(fxx::foo);
        "@);

        assure_compile_fail(@"
        import woo::std;

        namespace fxx
        {
            alias option<T> = void;

            func foo<T>(_)=> option<T>
            {
                return ::option::none: option<T>;
            }
        }
        do func(_: (int)=>option<int>){}(fxx::foo);
        "@);

        assure_compile_success(@"
        import woo::std;

        namespace interface{
            using Instance = dynamic;
        }
        protected using Proxy = struct {
            work: (interface::Instance,) => void,
        };
        protected let proxy<T> = Proxy {
            work = \self = self->unsafe::cast:<T>->typeof:<T>::work();
        };
        namespace int
        {
            func work(_: int){}
        }
        do proxy:<int>;
        "@);

        assure_compile_fail(@"
        import woo::std;

        namespace interface{
            using Instance = dynamic;
        }
        protected using Proxy = struct {
            work: (interface::Instance,) => void,
        };
        protected let proxy<T> = Proxy {
            work = \self = self->unsafe::cast:<T>->typeof:<T>::work();
        };
        do proxy:<int>;
        "@);
        
        assure_compile_success(@"
        enum Demo
        {
            A, B
        }
        namespace Demo
        {
            func operator * (a, b)
            {
                return a + b;
            }
        }
        do Demo::A * Demo::B;
        "@);
        assure_compile_fail(@"
        enum Demo
        {
            A, B
        }
        namespace Demo
        {
            func operator * (a, b)
            {
                return (a + b) + "";
            }
        }
        do Demo::A * Demo::B;
        "@);

        assure_compile_fail(@"
        enum Demo
        {
            A, B
        }
        namespace Demo
        {
            func operator * (_, _)
            {
            }
        }
        let mut a = Demo::A;
        a *= Demo::B;
        "@);
        assure_compile_success(@"
        enum Demo
        {
            A, B
        }
        namespace Demo
        {
            func operator * (_, _)
            {
            }
        }
        let mut a = Demo::A;
        a * Demo::B;
        "@);

        assure_compile_fail(@"
        do typeid:<typeof(foo)>;
        func foo()
        {
            do abc;
        }
        "@);

        assure_compile_fail(@"
        do typeid:<typeof(foo)>;
        let foo = abc;
        "@);

        assure_compile_fail(@"
        func foo()
        {
            f->read(b, 256) <| cc;
        }
        "@);

        assure_compile_fail(@"
        import woo::std;

        using mx = struct{a: int, a: int};
        "@);

        assure_compile_fail(@"
        let mx = struct{a = 0, a = 0};
        "@);

        assure_compile_fail(@"
        using mx = struct{a: int, b: int};
        let m = mx{a = 0, a = 0};
        "@);

        assure_compile_fail(@"
        let v<T> = 1 + T{};
        do v:<int>;
        "@);

        assure_compile_success(@"
        let v<T> = 1 + T{};
        do typeid:<typeof(v:<int>)>;
        "@);

        assure_compile_fail(@"
        let a = do nil;
        let mut b = 5;
        b += a;
        "@);

        assure_compile_success(@"
        let a = 0;
        let mut b = 5;
        b += a;
        "@);

        // ISSUE: 1.13: anything has been removed from woolang.
        // assure_compile_success(@"
        //     import woo::std;

        //     func foo()
        //     {
        //         if ([]->get(0) is option<anything>)
        //             ;
        //         else
        //         {
        //             return 0;
        //         }
        //     }

        //     foo() as void;
        // "@);

        assure_compile_fail("let a = a + 1;");
    }

    func main()
    {
        let test_threads = []mut: vec<thread>;
        for (let mut i = 0 ; i < 0; i += 1)
            test_threads->add(thread::create(test_compile_success_or_fail, ()));

        test_compile_success_or_fail();

        for (let t : test_threads)
            do t->wait();
        
        ////////////////////////////////////////////////////////////////

        let begin_tm = std::time();
        std::println("Compile 1000 vm!");

        for (let mut i=0; i<1000; i += 1)
        {
            assure_compile_success(@"
                import woo::std;
                func demo<T>(val: T)
                {
                    return "Hello" + val: string;
                }
                func main()
                {
                    do demo("world");
                    do demo(123);
                    do demo(1.72);
                    do demo(0x0000H);
                }
            "@);
        }
        let end_time = std::time();
        std::println("Compile 1000 src cost:", end_time - begin_tm);
    }
}

test_function("test_compile.main", test_compile::main);
